了解しました。SpringのCRUD APIをそのまま活かし、イントラ向けPWAとしてIonic ReactでUIを再構築する前提で、
「MVC → レイヤードアーキテクチャ → 5層モデル」へのステップアップ学習手順を深掘りします。
各ステップでは、Java中級・React初級者向けに実務を意識した学習順、設計観点、実装のポイントを掘り下げます。

リソースには実践記事やサンプルコード、構成例なども含めてご紹介します。完了後にご案内しますので、少々お待ちください。 

# MVCからレイヤードアーキテクチャ、5層モデルへのステップアップ学習計画

イントラネット向けPWAのフロントエンド（Ionic React）と、既存のSpring Framework製CRUDバックエンドAPIを連携するプロジェクトにおいて、アーキテクチャ設計を段階的にステップアップして学んでいきます。Java中級者でReact初級者の開発者が、既存資産を活かしつつ体系的に設計力を伸ばせるよう、**MVC**から**レイヤードアーキテクチャ**、さらにフロントエンドの**5層モデル**へと発展させる学習計画を以下に整理します。

## 1. Spring MVCの復習

**Spring MVCの基本原理と役割**：まずはSpring MVCの仕組みと各コンポーネントの役割を再確認します。Spring MVCはソフトウェア設計パターンであるMVC(Model-View-Controller)を採用しており、アプリケーションを**モデル（データ・ビジネスロジック）**, **ビュー（UI）**, **コントローラ（制御ロジック）**の三つに分割します ([Spring MVCとは？Bootとの違いや特徴、必要なスキルも紹介 | エンジニアスタイル](https://engineer-style.jp/articles/9746#:~:text=MVC%E3%81%A8%E3%81%AF%E3%80%81Model))。これによりコードの再利用性が向上し、各部分を分離して保守しやすくなります。Springでは特に**フロントコントローラーパターン**（Front Controller）を実装しており、`DispatcherServlet`という単一のフロントコントローラがすべてのリクエストを一旦受け取って適切なコントローラに振り分けます ([Spring MVC についてまとめてみるよ！！！ #spring - Qiita](https://qiita.com/PonPon3/items/76318ab3524c43630761#:~:text=MVC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AFweb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%82%8B%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%88%9D%E3%82%81%E3%81%A6reils%E3%81%A7%E3%83%9D%E3%83%BC%E3%83%88%E3%83%95%E3%82%A9%E3%83%AA%E3%82%AA%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86%E3%81%A8%E3%81%97%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%83%95%E3%81%AF%E5%88%9D%E3%82%81%E3%81%A6%E7%9F%A5%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%E3%81%9F%E3%81%A0%E3%80%81SpringM%20VC%E3%81%AF%E5%8E%B3%E5%AF%86%E3%81%AB%E3%81%AF%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%83%95%E3%82%82%E5%8D%81%E5%88%86%E3%81%AB%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%8C%E3%80%81%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%82%92%E4%B8%80%E6%97%A6%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%20%E3%83%BC%E3%81%A8%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%20%E3%82%89%E3%81%97%E3%81%84%E3%80%82))。この構造により共通処理の集中管理が可能です。

- **Controller（コントローラ）**：ユーザからの入力リクエストを受け取り、適切な**サービスやモデル**に処理を委譲し、結果をビューに渡します。いわばアプリケーション動作の「司令塔」であり、ユーザ要求に対する処理フローを決定します ([Spring MVCとは？Bootとの違いや特徴、必要なスキルも紹介 | エンジニアスタイル](https://engineer-style.jp/articles/9746#:~:text=Controller))。Springでは`@Controller`や`@RestController`を用いて実装し、メソッドに`@RequestMapping`/`@GetMapping`等でURLルーティングを定義します。
- **Model（モデル）**：アプリケーションのデータやビジネスルールを表現する部分です。たとえば**Entityオブジェクト**（データベースのレコードに対応するクラス）や**DTO**（データ転送オブジェクト）などが該当します。モデルはコントローラやビューにデータを提供し、ユーザ操作に応じてデータを更新します ([Spring MVCとは？Bootとの違いや特徴、必要なスキルも紹介 | エンジニアスタイル](https://engineer-style.jp/articles/9746#:~:text=Model))。Springでは`Model`や`ModelMap`を利用してコントローラからビューにデータを渡したり、ドメインモデルとしてエンティティクラスや値オブジェクトを設計します。
- **View（ビュー）**：ユーザーインターフェース部分で、モデルから受け取ったデータを使って画面表示を行います ([Spring MVCとは？Bootとの違いや特徴、必要なスキルも紹介 | エンジニアスタイル](https://engineer-style.jp/articles/9746#:~:text=View))。通常Spring MVCではThymeleafやJSPなどテンプレートエンジンを介してHTMLを生成しますが、今回のように**REST API**として提供する場合はJSONなどのデータシリアライズがビューの役割を担います。Springでは`ViewResolver`や`HttpMessageConverter`がビューの生成を助け、`@ResponseBody`や`ResponseEntity`によってJSONレスポンスを返しています。

**Spring MVCで使われる設計パターン**：上記のMVCに加え、SpringはDI（依存性注入）コンテナを備えており、各層のコンポーネントを**シングルトン管理**したり**IoC**により制御の反転を行っています。また、データアクセスにはDAO/Repositoryパターン、入力検証にはValidatorパターンなど、役割ごとに適切なデザインパターンを導入できます。特に**DAO/リポジトリ**はデータベース操作を抽象化するためにSpringでよく使われ、サービス層から呼び出してビジネスロジックとデータアクセスを分離します。

**既存APIの再活用ポイント**：既にSpringベースでCRUD機能を持つREST APIが存在する前提ですので、**バックエンドのロジックをできるだけ再利用**することが重要です。具体的には、フロントエンド側で同じ業務ロジックを重複実装しないように、**既存のコントローラ/APIエンドポイントを有効活用**します。例えば、追加のビジネス要件が出てもまずは現在のAPI群（例：顧客情報の取得APIや更新APIなど）で対応できないか検討し、不足する場合は新たなAPIエンドポイントをSpring側に追加します。Spring MVCの設計に沿っていれば、コントローラ -> サービス -> リポジトリの流れで処理が実装されているはずなので、必要に応じて**サービス層のメソッドを拡張**して再利用し、コントローラやAPIの追加実装コストを抑えます。既存コードを洗い直し、例えば**バリデーション**や**ビジネスルール**がコントローラ内に直接書かれている場合はサービス層に移して共有化する、といったリファクタも検討します。これらの見直しによって、後述するレイヤードアーキテクチャへの移行準備とします。

## 2. レイヤードアーキテクチャの理解

**レイヤードアーキテクチャとは何か**：MVCの考え方を発展させて、アプリケーション全体を責務ごとにいくつかの**層（レイヤー）**に分割するスタイルがレイヤードアーキテクチャです ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%83%89%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%81%A8%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E3%81%AE%E5%B1%A4%E3%81%AB%E5%88%86%E5%89%B2%E3%81%97%E3%80%81%E5%90%84%E5%B1%A4%E3%81%8C%E7%89%B9%E5%AE%9A%E3%81%AE%E5%BD%B9%E5%89%B2%E3%82%92%E6%8C%81%E3%81%A4%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%99%E3%80%82))。各レイヤーは固有の役割を持ち、**上位のレイヤーが下位のレイヤーにのみ依存**する形で構築します（依存の方向は一方向）。典型的なレイヤードアーキテクチャは以下のような構成です：

- **プレゼンテーション層（Presentation Layer）** – ユーザーとのインターフェースを担う層です。Webならコントローラや画面、モバイルならUIコンポーネントに相当します。ユーザーからの入力受付やレスポンス生成など、表示に関する処理を行います ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,Layer%EF%BC%89%20%E3%83%97%E3%83%AC%E3%82%BC%E3%83%B3%E3%83%86%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%B1%A4%E3%81%A8%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%B1%A4%E3%81%AE%E6%A9%8B%E6%B8%A1%E3%81%97%E3%82%92%E8%A1%8C%E3%81%86%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B9%E3%83%88%E3%82%A2%E3%81%AE%E4%B8%AD%E9%96%93%E3%81%AB%E4%BD%8D%E7%BD%AE%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E4%B8%BB%E3%81%AA%E5%BD%B9%E5%89%B2%E3%81%AF%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E5%87%A6%E7%90%86%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AB%E3%83%BC%E3%83%AB%E3%81%AE%E5%AE%9F%20%E8%A1%8C%E3%80%81%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AA%E3%81%A9%E3%81%A7%E3%81%99%E3%80%82%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%B1%A4%E3%81%AF%E3%80%81Presentation%20Layer%E3%81%A8Domain%20Layer%E3%81%AE%E9%96%93%E3%81%A7%E6%83%85%E5%A0%B1%E3%82%92%E3%82%84%E3%82%8A%E3%81%A8%E3%82%8A%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEAPI%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。今回のシステムでは**Ionic Reactアプリの画面部分**およびバックエンドのSpring MVCコントローラがこの層に当たります。
- **アプリケーション層（Application Layer）** – プレゼンテーションとドメインの橋渡しを行う層で、ユースケース（具体的な操作シナリオ）の進行役です ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E5%B1%A4%29%E3%81%AE%E4%B8%AD%E9%96%93%E3%81%AB%E4%BD%8D%E7%BD%AE%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%B1%A4%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%9B%BA%E6%9C%89%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AB%E3%82%84%E6%A6%82%E5%BF%B5%E3%82%92%E8%A1%A8%E7%8F%BE%E3%81%97%E3%80%81%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AB%E3%82%84%E6%A6%82%E5%BF%B5%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E9%80%9A%E5%B8%B8%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%B1%A4%E3%81%AE%E8%A6%81%E6%B1%82%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E5%AE%9F%E8%A1%8C%20%E3%81%95%E3%82%8C%E3%80%81%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E9%82%84%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。主に**ビジネスロジックの調整やデータ加工、トランザクション管理**を担います。プレゼンテーションから呼び出されてドメインの処理を指示し、その結果をプレゼンテーションに返すAPIを提供します。Springでは一般に**サービスクラス**（`@Service`）が該当し、業務処理をまとめる役割を果たします。
- **ドメイン層（Domain Layer）** – ビジネス領域の核心を担う層です。システムの**ビジネスルールや重要な概念（エンティティ、値オブジェクト、ドメインサービスなど）**を実装します ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E5%B1%A4%EF%BC%88Infrastructure%20Layer%EF%BC%89%20%E3%83%87%E3%83%BC%E3%82%BF%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E5%B1%A4%E3%80%82%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B9%E3%83%88%E3%82%A2%E3%80%81%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%80%81%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E3%81%AA%E3%81%A9%E3%80%81%E7%89%A9%E7%90%86%E7%9A%84%E3%81%AA%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%B1%A4%E3%81%A8%E3%81%AE%E9%96%93%E3%81%A7%E6%83%85%E5%A0%B1%E3%82%92%E3%82%84%E3%82%8A%E3%81%A8%E3%82%8A%E3%81%97%20%E3%81%BE%E3%81%99%E3%80%82%E4%B8%BB%E3%81%AA%E5%BD%B9%E5%89%B2%E3%81%AF%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E6%B0%B8%E7%B6%9A%E5%8C%96%E3%80%81%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%8E%A5%E7%B6%9A%E3%80%81%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E7%AE%A1%E7%90%86%E3%81%AA%E3%81%A9%E3%81%A7%E3%81%99%E3%80%82))。アプリケーション層から呼び出されて業務処理を実行し、結果を返します。ビジネスルールを表現するこの層は、可能な限り他の技術的要素から独立していることが望ましく、純粋なJavaオブジェクトによる実装（POJO）で構成します。例えば「注文金額の計算」「入力データのドメインルール検証」といった処理を担当します。
- **インフラストラクチャ層（Infrastructure Layer）** – 永続化や外部システム連携など、技術的な詳細を扱う層です ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=))。データベースとのやり取り（DAO/リポジトリ）、ファイル操作、ネットワーク通信、認証基盤との連携などが含まれます。ドメイン層やアプリケーション層の処理を支える汎用サービスを提供し、例えばSpring Data JPAのリポジトリや外部APIクライアント、メール送信クラスなどが該当します。

なお、場合によっては上記に**クロスカッティング層（Cross-cutting Layer）**を加えた5層とすることもあります ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%83%89%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%82%925%E5%B1%A4%E3%81%AB%E5%88%86%E5%89%B2%E3%81%99%E3%82%8B%E3%81%A8%E3%80%81%E6%AC%A1%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。クロスカッティング層とは**全体に横断的に影響する共通機能**を扱う層で、典型例として**ログ記録**, **例外処理**, **セキュリティ（認証・認可）**, **キャッシング**などがあります。SpringではAOPを用いて各層に横断的関心事を差し込むことができますが、設計上も横断的関心を意識してモジュール化すると見通しが良くなります。

**MVCとの違いと実務での活かし方**：MVCは主にプレゼンテーション層内部の分割（入力→制御→表示の分離）に焦点がありました。一方レイヤードアーキテクチャは、**アプリケーション全体構造を縦に分割**しており、特にドメインロジックと技術的実装の分離を強調します。実務においては、レイヤードアーキテクチャを採用することで**モジュール性**と**保守性**が向上します。各層が明確に責務分担されているためコードが理解しやすくなり、変更や機能追加の影響範囲を局所化できます ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,%E6%9F%94%E8%BB%9F%E6%80%A7))。例えば「UI変更だけどドメインには影響なし」「DB変更だけどドメインロジックはそのまま」など、層境界のおかげで影響箇所を絞り込めます。また**並行開発**もしやすく、UIチームとドメインロジックチームで作業を分けたり、テストも層ごと（ユニットテスト、統合テストなど）に実施できます。

実務でレイヤードアーキテクチャを活かすポイントは次の通りです:

- **責務の分離とコード再利用**：ビジネスロジックをサービス層に集約し、コントローラやリポジトリから分離します。サービス層にまとめることで、複数の画面やAPIから同じロジックを呼び出せるため再利用性が高まります。実際、Springでは`@Service`クラスにビジネスロジックを実装しコントローラから呼び出すのが一般的です。「サービス層でビジネスロジックを分離し再利用可能に実装することが重要」です ([主要なSpringアノテーションの役割と使い方 | 株式会社一創](https://www.issoh.co.jp/tech/details/2639/#:~:text=%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%81%A7%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E5%88%86%E9%9B%A2%E3%81%97%E3%80%81%E5%86%8D%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%AA%E6%96%B9%E6%B3%95%E3%81%A7%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82%20%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E4%BF%9D%E5%AE%88%E6%80%A7%E3%81%A8%E3%83%86%E3%82%B9%E3%83%88%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E5%90%91%E4%B8%8A%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%82%92%E8%A8%AD%E8%A8%88%E3%81%97%E3%81%BE%E3%81%99%EF%BC%9A))。これによりコードの保守性とテスト容易性が向上します。
- **層間インタフェースの明確化**：各レイヤー間のデータの受け渡しは**インタフェースやDTO**を介して行い、直接下位層の実装に依存しないようにします。例えばリポジトリ層にはリポジトリインタフェース（もしくはDAOインタフェース）を定義し、ドメイン層やサービス層はそれに依存します。こうするとデータソースが変わっても上位レイヤーを修正せずに済みます。実際のSpring開発でも、`CustomerRepository`インタフェースを定義してJPA実装クラスはSpringが自動生成し、サービス層はインタフェース経由でDB操作しています。
- **トランザクションやバリデーションの配置**：業務トランザクションの境界はサービス層で管理し（Springの`@Transactional`をサービス層メソッドに付与）、プレゼンテーション層から呼び出すようにします。また入力値の検証は**できるだけ下位の適切な層で実施**します。ユーザ入力チェックはプレゼンテーション層でも行いますが、ビジネスルール上の検証（例：契約上限チェックなど）はドメイン層で担保するといった具合です。こうすることで、不正なデータが下位に伝わるのを防ぎつつ、各層の責務に沿った堅牢性を実現します。
- **既存コードへの適用**：既にSpring MVCで実装されたCRUD APIがある場合、その内部実装が「コントローラで直接リポジトリ操作」など単純な構成でも、段階的にリファクタリングしてレイヤードアーキテクチャに近づけます。具体的には**サービス層が無ければ新設**し、コントローラの処理をサービスクラスに移譲します。またエンティティを直接外部に返している場合は**DTO**を用意してプレゼンテーション層とドメイン層の間でデータを受け渡すようにすると、将来的な変更に強くなります。現場で採用しやすいのは、まずは3層（プレゼンテーション・サービス・リポジトリ）に分けるシンプルな形から始め、必要に応じてドメイン層（エンティティにメソッドを持たせる、ドメインサービスクラスを作る等）の表現力を高めていく方法です。

**補足**：レイヤードアーキテクチャにはデメリットもあります。例えば層が増えることで設計・実装が多少複雑化し、処理経路が長くなることでパフォーマンスに影響する可能性があります ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,%E3%82%B3%E3%82%B9%E3%83%88%EF%BC%88%E9%96%8B%E7%99%BA%2Fi%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%EF%BC%89%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E8%A4%87%E6%95%B0%E3%81%AE%E5%B1%A4%E3%81%AB%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E5%88%A5%E3%80%85%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E9%96%8B%E7%99%BA%E3%82%B3%E3%82%B9%E3%83%88%E3%82%84%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%B3%E3%82%B9%E3%83%88%E3%81%8C%E5%A2%97%E5%8A%A0%E3%81%99%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。しかしこれらは適切な設計と層間のインターフェース定義で十分コントロール可能であり、得られる保守性のメリットの方が大きいでしょう。特に中長期で保守・機能追加が続く業務システムでは標準的な手法として定着しています。

## 3. クリーンアーキテクチャとの比較

次に、より発展的なアーキテクチャである**クリーンアーキテクチャ**との比較を通じて、レイヤードアーキテクチャ採用の意図を確認します。

**クリーンアーキテクチャの概要**：クリーンアーキテクチャ（Clean Architecture）はRobert C. Martin（通称Uncle Bob）が提唱したアーキテクチャ哲学で、**ドメイン（ビジネスルール）を中心**に据え、UIやデータベースなどの実装詳細から独立させることを目指したものです。クリーンアーキテクチャでは一般に同心円状のレイヤーを持ち、内側から順に**エンティティ（Entities）**, **ユースケース/インタラクター（Use Cases / Interactors）**, **インターフェースアダプタ（Interface Adapters）**, **フレームワーク＆ドライバ（Frameworks & Drivers）**といった構成を取ります。依存関係は内側に向かう一方向のみ許され、UIやDBといった**外側の要素が内側のドメインルールに依存**し、逆方向は参照しないことが厳守されます。このために**依存性逆転の原則（DIP）**を適用し、例えばドメイン層がインフラ層の実装に依存しないように**抽象インターフェース**を介してやり取りします。要するに、「ビジネスロジックがフレームワークやデータアクセスの詳細に影響されない」ことを理想としたアーキテクチャです。

**レイヤードアーキテクチャとの比較**：従来のレイヤードアーキテクチャでは、ドメイン層が下位のインフラ層に直接依存してしまいがちという課題が指摘されています ([DDDの一般的なアーキテクチャをまとめてみた](https://zenn.dev/ayumukob/articles/ff183004d09ede#:~:text=%E5%95%8F%E9%A1%8C%E7%82%B9))。例えばサービスクラスやエンティティが直接リポジトリ（DBアクセス）クラスに依存すると、そのドメインロジックは特定のDB技術に引きずられ、他の環境への移植や単体テスト時のスタブ化が難しくなります。クリーンアーキテクチャはこの点を解決すべく、**依存関係の向きを反転**させます。具体的には、ドメイン層がインターフェースを定義し、インフラ層がそれを実装する形にすることで、ドメイン -> インフラの直接依存を無くします。これによりドメインロジックは完全に独立し、フレームワーク（Springなど）やDBといった詳細から切り離されます。極端に言えば、ドメイン層はSpringの存在すら知らずに動作でき、インフラ層を差し替えることで容易に技術変更に対応できるわけです。

もう一つの違いは、クリーンアーキテクチャの方が**層が細分化**されている点です。レイヤードアーキテクチャが3〜5層程度の区分であるのに対し、クリーンアーキテクチャではユースケースやエンティティの層が独立して存在し、UIからDBまで段階的に依存逆転用の境界が設けられます。その結果、**コード量や抽象化のためのクラス/インターフェースが増える**傾向にあります。例えばCRUD一つ実装するにも、コントローラ->ユースケース->リポジトリインターフェース->リポジトリ実装->エンティティというように関与するコンポーネントが多くなります。

**なぜ現場でレイヤードアーキテクチャが採用されやすいのか**：クリーンアーキテクチャの思想は非常に有用ですが、現実のプロジェクトですべてをこの通りに実装するのはハードルが高い場合があります。最大の理由は**シンプルさと生産性のバランス**です。レイヤードアーキテクチャは構造が直感的であり、開発メンバー全員が理解しやすいという利点があります。特にSpringなど既存フレームワークの多くはレイヤードな設計を前提としており、学習コストが低いです。一方、クリーンアーキテクチャは高度な抽象化を要求し、開発チームにDDDやデザインパターンの深い理解が必要になります。適切に運用しないと**過度な抽象化によって開発効率が落ちてしまう**ことも多いと指摘されています ([クリーンアーキテクチャの功罪](https://zenn.dev/adwd/articles/5d4a89262f4fc5#:~:text=%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A8%E3%81%84%E3%81%86%E3%81%A8%E8%A8%AD%E8%A8%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E9%8A%80%E3%81%AE%E5%BC%BE%E4%B8%B8%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E6%89%B1%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E8%A8%98%E4%BA%8B%E3%82%92%E3%82%88%E3%81%8F%E8%A6%8B%E3%81%BE%E3%81%99%E3%80%82%E3%81%97%E3%81%8B%E3%81%97%E8%87%AA%E5%88%86%E3%81%AE%E7%B5%8C%E9%A8%93%E3%81%A0%E3%81%A8%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%20%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A7%E6%9B%B8%E3%81%8B%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%AB%E3%82%82%E3%81%8B%E3%81%8B%E3%82%8F%E3%82%89%E3%81%9A%E9%96%8B%E7%99%BA%E5%8A%B9%E7%8E%87%E3%81%8C%E8%90%BD%E3%81%A1%E3%81%A6%E3%81%84%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E4%BA%8B%E3%81%8C%E5%A4%9A%E3%81%8F%E3%80%81%E3%81%84%E3%81%A4%E3%81%A7%E3%82%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%91%E3%81%B0%E3%81%84%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E3%82%82%E3%81%AE%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。実際、「クリーンアーキテクチャで実装したのにかえって開発が非効率になった」というケースは少なくなく、必ずしも銀の弾丸ではないとの声もあります。

現場ではまず**「確実に機能するシンプルな構成」**が求められることが多いです。レイヤードアーキテクチャは必要十分な分割であり、変更要求にもそこそこ耐えられるバランスの良いアーキテクチャです。多くの企業で**典型的な業務システムのひな形**として受け入れられているため、新メンバーもキャッチアップしやすく、チーム開発での共通認識を持ちやすいという実利があります ([DDDの一般的なアーキテクチャをまとめてみた](https://zenn.dev/ayumukob/articles/ff183004d09ede#:~:text=,%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%81%AE%E5%85%A5%E5%87%BA%E5%8A%9B%E3%82%92%E3%81%99%E3%82%8B%E5%B1%A4))（レイヤードアーキテクチャ導入により各層の凝集度が上がり、巨大なサービスクラス（=神クラス）の乱立を防げるためメンテナンス性が向上することも大きいです）。一方でクリーンアーキテクチャは**規模や期間、メンバーのスキルに応じて取捨選択**すべきものです。すべてのプロジェクトに画一的に適用すれば良いわけではなく、むしろ小中規模のプロジェクトでは過剰設計になりかねません。「ソフトウェアアーキテクチャに絶対的な正解はなく、目的に応じた設計判断が大切」という前提に立つと、現場では理解・実装しやすいレイヤードアーキテクチャが採用されやすいと言えます。

**結論として**、クリーンアーキテクチャの考え方（依存性逆転やドメイン駆動の発想）は非常に勉強になりますので、その知見を踏まえた上で現在のプロジェクトではまず**レイヤードアーキテクチャをしっかり実践**することが望ましいでしょう。将来的に必要性が出てきたら一部にDIPを導入したりモジュールを分離する、といった拡張も可能です。まずはレイヤードアーキテクチャで堅実な土台を作り、段階的にクリーンアーキテクチャのエッセンスを取り入れていく方針が現実的です。

## 4. フロントエンド側の5層モデルの導入

バックエンドだけでなく**フロントエンドにもアーキテクチャパターンを適用**することで、大規模化した際のコード管理や機能追加の容易さが向上します。ここではIonic Reactを用いたフロントエンドに対し、5層モデルと呼ばれる設計アプローチを導入することを検討します ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=%E4%BB%A5%E4%B8%8B%E3%81%AE5%E3%81%A4%E3%81%AE%E5%B1%A4%E3%81%AB%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%82%92%E5%88%86%E5%89%B2%20Controller%E5%B1%A4%20Interaction%E5%B1%A4%20Model%E5%B1%A4%20View%E5%B1%A4,Infra%E5%B1%A4))（参考：フロントエンドアプリケーションの共通アーキテクチャパターン事例）。フロントエンドの5層モデルは以下の層で構成されます。

- **View（ビュー）層**：画面表示を担当する層です。ReactのUIコンポーネントやページそのものが該当します。ビュー層ではModel層のオブジェクトやデータを組み合わせて実際の画面（HTML要素）を構築し、ユーザーに見せます ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=View%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))。Ionicの各種UIコンポーネント（IonButtonやIonList等）やページコンポーネントがこの役割を担い、UIのレイアウトやスタイリング、ユーザーからの入力フォームなどを定義します。ビューは基本的に表示ロジックに専念し、ビジネスロジックは含みません。
- **Controller（コントローラ）層**：ビューから発生するユーザーの操作を受け取り、適切な処理（Interaction層のメソッド呼び出しなど）を実行してその結果をビューに提供する層です ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Controller%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))。いわゆる画面ごとの**イベントハンドラや画面ごとの制御ロジック**に相当します。Reactでは明確なControllerクラスはありませんが、概念的には**各ページコンポーネントがコントローラの役割**を果たします。例えばページコンポーネント内で`useEffect`フックを使って初期データを読み込んだり、ボタンクリック時のハンドラ内でInteraction層の関数を呼び出す部分がController層の責務です。URLルーティングによる画面切り替えもここで扱います。Ionic Reactでは`IonReactRouter`や`IonPage`コンポーネントを用いてページ遷移を管理しますが、その各ページコンポーネントが裏でコントローラ的な動きをしています。
- **Interaction（インタラクション）層**：画面上で実現したい機能（ユースケース）を具体的に遂行する層です。Controller層とModel層を仲介し、必要ならバックエンドAPIを呼び出してモデルを組み立て、処理結果をコントローラに返します ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%A8Controller%E5%B1%A4%E3%81%AE%E8%AA%BF%E6%95%B4%E3%82%92%E8%A1%8C%E3%81%86%E5%B1%A4%E3%80%82%E7%94%BB%E9%9D%A2%E3%81%A7%E5%AE%9F%E7%8F%BE%E3%81%97%E3%81%9F%E3%81%84%E8%A6%81%E6%B1%82%E3%82%92%E8%A8%98%E8%BC%89%E3%81%99%E3%82%8B%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E6%A9%9F%E8%83%BD%E5%8D%98%E4%BD%8D%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%B5%81%E3%82%8C%E3%81%AF%E4%BB%A5%E4%B8%8B%E3%81%AE%E9%80%9A%E3%82%8A%E3%81%A8%E3%81%AA%E3%82%8B%20%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E5%A0%B4%E5%90%88%20%E3%83%BB%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%A8%E3%81%AE%E9%80%9A%E4%BF%A1%20%E3%83%BB,Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E7%94%9F%E6%88%90%20%E3%83%BB%E8%BF%94%E5%8D%B4%E3%81%95%E3%82%8C%E3%81%9F%E9%80%9A%E4%BF%A1%E7%B5%90%E6%9E%9C%E3%82%92Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E8%A8%AD%E5%AE%9A%20%E3%83%BBController%E5%B1%A4%E3%81%B8%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E5%8D%B4))。**ユースケース単位**でクラスや関数を用意するイメージで、「〇〇一覧を取得してフィルタし、△△を計算して返す」といった一連の処理をここで実装します。例えば「ユーザの入力を受けて、バックエンドからデータ取得→Modelオブジェクトに詰め替え→結果を返却」という流れです ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%A8Controller%E5%B1%A4%E3%81%AE%E8%AA%BF%E6%95%B4%E3%82%92%E8%A1%8C%E3%81%86%E5%B1%A4%E3%80%82%E7%94%BB%E9%9D%A2%E3%81%A7%E5%AE%9F%E7%8F%BE%E3%81%97%E3%81%9F%E3%81%84%E8%A6%81%E6%B1%82%E3%82%92%E8%A8%98%E8%BC%89%E3%81%99%E3%82%8B%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E6%A9%9F%E8%83%BD%E5%8D%98%E4%BD%8D%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%B5%81%E3%82%8C%E3%81%AF%E4%BB%A5%E4%B8%8B%E3%81%AE%E9%80%9A%E3%82%8A%E3%81%A8%E3%81%AA%E3%82%8B%20%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E5%A0%B4%E5%90%88%20%E3%83%BB%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%A8%E3%81%AE%E9%80%9A%E4%BF%A1%20%E3%83%BB,Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E7%94%9F%E6%88%90%20%E3%83%BB%E8%BF%94%E5%8D%B4%E3%81%95%E3%82%8C%E3%81%9F%E9%80%9A%E4%BF%A1%E7%B5%90%E6%9E%9C%E3%82%92Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E8%A8%AD%E5%AE%9A%20%E3%83%BBController%E5%B1%A4%E3%81%B8%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E5%8D%B4))。バックエンドAPIが不要な場合はModelのメソッド操作だけで結果を生成します ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%20%E3%83%BBModel%E5%B1%A4%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E5%AE%9F%E8%A1%8C%20%E3%83%BBController%E5%B1%A4%E3%81%B8%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E5%8D%B4))。React実装では、この層は**カスタムフック**や**サービスモジュール**として実装することが考えられます。例えば`useFetchCustomers`フック内でAPI通信とモデル生成を行う、といった具合です。またReduxなどの状態管理ライブラリを使う場合、Action CreatorやThunk/Sagaなどがこの層の役割を担うことになります。
- **Model（モデル）層**：表示するデータを保持し、必要な操作（検索や加工）を提供する層です ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))。フロントエンドにおけるModel層は、バックエンドから取得したデータを保持する**オブジェクトやデータ構造**を指します。単にデータを保持するだけでなく、モデル内に**ビジネスルールに沿ったメソッド**を持たせることもあります（例：リストから特定の条件の項目を抽出する`filter`メソッド等）。Ionic ReactではTypeScriptの**型定義やクラス**を用いてモデルを表現できます。例えば`Customer`クラスを定義し、顧客リストに対する操作（ソートやフィルタ）をメソッドとして実装することで、Interaction層から利用します。Model層はフロントエンドの見通しを良くするため**先に設計・開発**すると良いと言われています ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))（画面UIはこのモデルに合わせて作られるため）。なお、小規模ならReduxのstateやContextそのものがModel代わりになりますが、大規模化するとモデルクラスを明示的に持つ設計が有効です。
- **Infra（インフラ）層**：外部ライブラリやバックエンドとの通信などを担当する層です ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Infra%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))。主に**APIクライアント**としての役割が大きく、例えば`fetch`や`axios`を使ってバックエンドのREST APIと通信する処理をここにまとめます ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Infra%E5%B1%A4%E3%81%AE%E5%BD%B9%E5%89%B2))。その他、地図表示用のMapライブラリやリアルタイム通信(Socket)ライブラリ、デバイス機能呼び出し（カメラ、ファイル保存等）もInfra層として実装します。Ionic固有のものでは、Capacitorによるネイティブ機能呼び出し（例：QRコードスキャン、プッシュ通知の受信など）が該当します。この層は**詳細実装**を含むためテストではモックに差し替えたり、将来的なライブラリ変更に備えてインタフェースで抽象化することも検討します。例えばAPI通信部分を`ApiClient`モジュールにまとめ、内部でaxiosを呼ぶようにしておけば、後で通信ライブラリを変えても影響を局所化できます。

**Ionic Reactへの当てはめ**：上記5層モデルをIonic Reactプロジェクトに適用する際の具体的な構成について述べます。Ionic Reactではプロジェクト構造上、`src/pages`配下にページコンポーネント（画面コンポーネント）があり、これがController+Viewの役割を担います。`src/components`には再利用可能な小さなViewコンポーネントが入ります。ここに**controllers**ディレクトリや**services（interaction）**ディレクトリを作成し、画面ロジックやユースケース処理を整理すると良いでしょう。例えば、`services/UserService.ts`にユーザ関連のInteractionロジック（API呼び出しとモデル生成）を実装し、ページコンポーネントからそのサービスを呼ぶようにします。また`models`ディレクトリを作り、`User.ts`や`Order.ts`といったモデルクラス・型定義を配置します。Infra層については、`api`ディレクトリに`ApiClient.ts`を置き、axiosインスタンスや通信処理関数（認証付きのfetch wrapper等）を実装します。Capacitorの各種プラグイン（例えばStorage, Camera等）を使う場合も、直接コンポーネントで呼ぶのではなくInfra層のモジュールにまとめ、必要に応じてInteraction層から呼び出すようにします。こうすることで、フロントエンドでも関心事が明確に分離され、例えば「API仕様が変わったが画面ロジックには影響なし」「画面を変更してもサービスロジックは再利用」といったメリットが得られます。

**React Hooksの活用**：5層モデルを支える実装テクニックとして、React Hooksを適切に使うことが重要です。特に`useState`と`useEffect`の使い方に習熟しましょう。Controller層（ページコンポーネント）では、`useState`で画面の表示データや入力データをステート管理し、`useEffect`で初期表示時にInteraction層の処理（API通信など）をキックします。例えば以下のようなパターンです：

```jsx
const [customers, setCustomers] = useState<Customer[]>([]);
const [loading, setLoading] = useState(false);
useEffect(() => {
  setLoading(true);
  UserService.fetchAllCustomers().then(data => {
    setCustomers(data);
  }).catch(err => {
    console.error(err);
    // エラー処理（例：トースト表示）
  }).finally(() => {
    setLoading(false);
  });
}, []); // 初回マウント時のみ実行
```

このようにフックを使うことで、コンポーネントのライフサイクルに合わせて非同期処理を発動できます。加えて、カスタムフックを自作するとInteraction層のロジックを再利用しやすくなります。例えば上記処理を`useCustomers`というカスタムフックに抽出し、他のコンポーネントからも呼び出せるようにすれば、同じ顧客取得ロジックを一箇所で管理できます。

**状態管理**について補足すると、小規模なら各ページコンポーネント内の`useState`で十分ですが、アプリが大きくなると**グローバル状態管理**が必要になります。Ionic Reactでは標準でReduxやMobXは組み込まれていませんが、ReactのContext APIを使って簡易的なグローバル状態管理が可能です。例えば認証ユーザ情報や複数ページで共有するフィルタ条件などはContextに保持し、どのコンポーネントからでも参照できるようにします。5層モデルで言えば、Contextで保持するデータはModel層の一部（アプリケーション全体のモデル）とみなせます。必要に応じてReduxや Zustand といったライブラリ導入も検討してください。業務アプリではフォーム入力や一覧データの状態管理が複雑になるため、早めに状態管理方針を定めておくことがポイントです。

## 5. バックエンドAPIとPWA画面をつなぐ実装の勘所

最後に、Spring BootによるバックエンドAPIとIonic React PWAフロントエンドを実際に連携させる際の重要ポイントについてまとめます。**認証**, **CRUD通信**, **状態管理**, **オフライン対応**, **Capacitor活用**といった観点で、実装例や注意点、関連フレームワークの使い方をガイドします。

- **認証（Authentication）:**  業務アプリではユーザー認証が必要になるケースが多いです。バックエンドがSpring Security等でJWT認証方式を採用しているなら、フロントエンドからログインAPIに対してユーザ資格情報を送り、取得したJWTトークンを以降の通信に使用します。クライアント側ではまず`/login`などの認証APIを呼び出し、返ってきたアクセストークンを**安全な場所に保存**します（セキュアな実装としては**HttpOnlyクッキー**にリフレッシュトークンを、メモリor安全なストレージにアクセストークンを保持する方法が考えられます ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=JWT%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E4%BB%96%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AB%E9%A0%BC%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E8%AA%8D%E8%A8%BC%E3%82%92%E8%A1%8C%E3%81%86%E4%B8%8A%E3%81%A7%E3%80%81%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E5%81%B4%E3%81%AFaccess_token%E3%82%92%E9%80%81%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%BE%E3%81%9F%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E7%84%A1%E5%8A%B9%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81r%20efresh_token%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%80%81%E6%96%B0%E3%81%9F%E3%81%AB%E6%9C%89%E5%8A%B9%E3%81%AAaccess_token%E3%82%92%E5%8F%96%E5%BE%97%E3%81%97%E7%9B%B4%E3%81%99%E3%81%93%E3%81%A8%E3%82%82%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82))）。保持したアクセストークンは以降のAPI呼び出し時にHTTPヘッダ（例：`Authorization: Bearer <token>`）に付与して送信します。これを確実かつ楽に行うため、**axiosなどHTTPクライアントのインターセプター**を利用すると便利です ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=export%20const%20authAxios%20%3D%20axios.create%28,%7D%2C%20withCredentials%3A%20true%2C))。例えばaxiosを使用する場合、`axios.interceptors.request.use`でリクエスト送信前にアクセストークンをヘッダに付与する処理を挟みます。また、認証トークンの**リフレッシュ**も実装しておきます。アクセストークンの有効期限が切れたら自動でリフレッシュトークンを送信して新しいトークンを取得し直す流れです ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=JWT%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E4%BB%96%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AB%E9%A0%BC%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E8%AA%8D%E8%A8%BC%E3%82%92%E8%A1%8C%E3%81%86%E4%B8%8A%E3%81%A7%E3%80%81%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E5%81%B4%E3%81%AFaccess_token%E3%82%92%E9%80%81%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%BE%E3%81%9F%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E7%84%A1%E5%8A%B9%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81r%20efresh_token%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%80%81%E6%96%B0%E3%81%9F%E3%81%AB%E6%9C%89%E5%8A%B9%E3%81%AAaccess_token%E3%82%92%E5%8F%96%E5%BE%97%E3%81%97%E7%9B%B4%E3%81%99%E3%81%93%E3%81%A8%E3%82%82%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82))。これもインターセプター内で401エラー（認証切れ）を検知して実行するとスムーズです。実装例として、認証状態とトークンを管理する`AuthContext`をReact Contextで用意し、ログイン時に`setAuthState({ token })`で状態更新、axiosインターセプターでその`token`を参照してヘッダ付加、期限切れ時は`/refresh`エンドポイントを叩いて`token`を更新…という形が考えられます。Ionic React自体は認証機構を持たないので、React標準のやり方＋CapacitorのSecure Storageプラグインなどを組み合わせて実装します。重要なのは、**トークンをクライアントに長期間保存しない**こと（可能ならHttpOnly Cookieに任せ、JSからはアクセストークンだけ扱う）、**画面遷移時に認証状態を考慮する**こと（未ログイン時はログインページにリダイレクトするなど）です。React Routerのガードを実装したり、全ページ共通で`AuthContext`をチェックしてガードを掛ける実装を入れると良いでしょう。

- **API通信とCRUD操作:**  フロントエンドからバックエンドのCRUD APIを呼び出す実装では、基本的に**HTTPクライアントを介した非同期通信**となります。Ionic Reactではブラウザ標準の`fetch`やサードパーティの`axios`がよく使われます。サービス層（Interaction層）にあたる部分で例えば以下のようなコードを実装します：
    ```typescript
    // UserService.ts (Interaction層のサービス例)
    import ApiClient from '../api/ApiClient';  // axiosをラップしたクライアント
    export async function fetchAllCustomers(): Promise<Customer[]> {
      const response = await ApiClient.get('/api/customers');
      return response.data as Customer[];  // 取得データをModel層に渡す
    }
    ```
    上記の`ApiClient`は例えば`axios.create`で作成したインスタンスで、共通の`baseURL`やヘッダ設定（認証トークン付与など）を施しています ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=export%20const%20authAxios%20%3D%20axios.create%28,%7D%2C%20withCredentials%3A%20true%2C))。こうしたラップを用意することで、毎回フルURLを書く手間や認証ヘッダ付与の重複を避けられます。通信処理では**エラーハンドリング**と**ローディング状態**の管理が重要です。エラー時には例外を投げて呼び出し元でキャッチし、ユーザーにトースト（`IonToast`）やダイアログで通知します。ローディング中は`IonLoading`コンポーネントやスピナーを表示してユーザーに処理中であることを示します。複数のAPIを順次呼ぶ場合は`async/await`やPromiseチェーンで制御しつつ、適宜ローディング状態を更新します。
    
    CRUD操作に関しては、React側での操作後に即座にUIに反映させる**楽観的更新**も検討します。例えば一覧表示中に削除操作を行った場合、APIレスポンスを待たずに一旦リストから項目を削除表示し、その後APIからエラーが返ったら復元するといったUX向上策です。ただ業務アプリでは整合性が重要なケースも多いため、まずはAPIレスポンスを待ってから画面更新するオーソドックスな方法で実装し、必要に応じて最適化するとよいでしょう。
    
    **React Hooksとの組み合わせ**: 上述のように、API呼び出しはサービスモジュールにまとめ、ページコンポーネントでは`useEffect`でサービス関数を呼び出します。データは`useState`で保持し、ユーザー操作（追加・更新・削除）はイベントハンドラ内で対応するサービス関数（例：`UserService.createUser(newUser)`など）を呼び、成功したらstateを更新して再レンダリング、という流れになります。ある程度規模が大きくなってきたら**React Query**（現: TanStack Query）などのデータフェッチング専用ライブラリを導入するのも有効です。React Queryを使うと、データのキャッシュやローディング・エラー状態管理を宣言的に書けるため、REST API呼び出しのボイラープレートが減ります。学習コストはありますが、業務アプリで頻繁にCRUD通信を行う場合は検討してください。

- **フロントエンドの状態管理:**  フロントエンドアプリでは、バックエンドから取得したデータやユーザー入力値など様々な状態(state)を扱います。小さなアプリなら各コンポーネント内部の`useState`で十分ですが、画面間でデータを共有したり、ログインユーザ情報をどこからでも参照したい場合などは**グローバル状態管理**が必要です。React標準の解決策はContext APIで、`AuthContext`や`AppStateContext`を作成してアプリ全体にプロバイダを適用し、値と更新関数を提供します。先述の認証情報（ユーザ名やJWTトークンなど）は`AuthContext`でグローバルに持ち回る設計にすると各コンポーネントで`useContext(AuthContext)`で簡単に参照できます。Ionic Reactでもこの方法は有効で、例として**ログイン状態**や**現在編集中のオブジェクト**などをContextで管理できます。
    
    プロジェクトが大規模化した場合は、ReduxやMobXといった専用の状態管理ライブラリ導入も検討します。Reduxは学習コストがありますがエコシステムが充実しており、開発チームで知見があれば強力な選択肢です。最近ではより軽量な**Zustand**や**Jotai**なども人気です。大事なのは、**状態の所在を明確にする**ことです。どのコンポーネントがどの状態を持ち、どこから更新されるのかを整理して設計しましょう。5層モデルで言えば、Model層に当たるデータをどこに保持するかがポイントで、単純なCRUDデータはReduxのstore（＝Model）に置き、フォーム入力値は各コンポーネントの内部stateに置く、などルールを決めます。また、Ionicはモバイル環境を意識しているため**画面遷移後にコンポーネントがアンマウント**されます。例えばタブを移動すると前のページコンポーネントは破棄されるので、その中のstateも失われます。そうした場合でも**戻ってきたときに前回のデータを保持したい**ならグローバルstateにする必要があります。Ionic Reactでタブ間ナビゲーションをする際は、各タブのルートページはアンマウントされない設定（`ionViewDidLeave`と`ionViewWillEnter`を活用する等）もありますが、基本的に**必要なデータは都度再取得 or グローバルに保存**を検討してください。
    
    なお、**CapacitorのStorage**やブラウザの`localStorage`/`IndexedDB`を使えばアプリを再起動・再読み込みしても状態を保持できます。例えばユーザが最後に入力していた内容を復元したい場合、アンマウント時に`localStorage`に保存し、マウント時に読み込むという方法も可能です。ただしローカルストレージは永続化できますが、機密情報（認証トークンなど）の保存は避け、必要最低限の利用に留めます ([ストレージ | Capacitorドキュメンテーション](https://capacitorjs.jp/docs/guides/storage#:~:text=%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8%E3%81%AF%E3%80%81%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BCID%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E5%B0%91%E9%87%8F%E3%81%AE%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E3%80%8Ctransient_%E3%80%8D%E3%81%A8%E8%A6%8B%E3%81%AA%E3%81%95%E3%82%8C%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A4%E3%81%BE%E3%82%8A%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%81%AF%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%9C%80%E7%B5%82%20%E7%9A%84%E3%81%AB%E5%A4%B1%E3%82%8F%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%82%92%E4%BA%88%E6%9C%9F%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%83%87%E3%83%90%E3%82%A4%E3%82%B9%E3%81%AE%E7%A9%BA%E3%81%8D%E5%AE%B9%E9%87%8F%E3%81%8C%E5%B0%91%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8B%E3%81%A8%E3%80%81OS%20%E3%81%8C%20Web%20View,%E3%81%A8%E3%81%97%E3%81%A6%E3%83%9E%E3%83%BC%E3%82%AF%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%20persisted%20storage%20API%20%E3%81%8C%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%A7%E3%81%99%EF%BC%89%E3%80%82%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%A7))。業務アプリでは画面遷移や再読み込みがあっても致命的な問題にならないよう、**サーバサイドに状態を持たせる**（サーバセッションやDBに一時保存）アーキテクチャも併用されますが、PWAではできるだけフロントで完結する方がオフライン対応に強くなります。

- **サービスワーカーとオフライン対応:**  PWA（Progressive Web App）の利点の一つに**オフラインでも動作する**ことがあります。IonicでビルドするPWAでは、デフォルトで**サービスワーカー（Service Worker）**用のスクリプトが生成されます。サービスワーカーはブラウザとは別スレッドで動作する特殊なワーカーで、**ネットワークプロキシのように振る舞ってリソースのキャッシュ制御**を行えます ([Progressive Web Applications: PWAとは - Ionic Documentation](https://ionicframework.com/docs/ja/core-concepts/what-are-progressive-web-apps#:~:text=))。具体的には、初回アクセス時にアプリの主要なリソース（HTML, JS, CSS, 画像など）をキャッシュに保存し、次回以降はネットワークに接続できなくてもキャッシュからそれらを供給することでアプリが起動・閲覧できます。この仕組みにより、イントラネット環境でサーバが一時的にダウンしてもユーザーが画面を開けたり、社外でオフライン時にもアプリのキャッシュデータを参照できるようになります。
    
    Ionicのビルド出力に含まれる`service-worker.js`は、デフォルトではアプリの静的アセットをキャッシュする設定になっています（Workboxというライブラリによるプリキャッシュ）。開発者は必要に応じてこの挙動をカスタマイズできます。例えば**APIのレスポンスデータをキャッシュ**してオフライン時に最後の結果を表示する、といったことも可能です。ただし動的データのキャッシュは古い情報をユーザーに見せてしまうリスクもあるため、要件に応じて慎重に設計してください。オフライン時の操作（例えばデータ更新を試みて失敗した場合の処理など）も含め、PWAならではの挙動を確認します。基本的な方針として、**読み取り系はキャッシュ活用、書き込み系はオフライン不可**とするケースが多いです。Ionic公式ドキュメントにもPWAのオフライン対応について記載がありますので参照してください ([Progressive Web Applications: PWAとは - Ionic Documentation](https://ionicframework.com/docs/ja/core-concepts/what-are-progressive-web-apps#:~:text=))。
    
    また、サービスワーカーは**アプリの更新**にも関係します。PWAでは新しいバージョンをデプロイしても、ユーザーのキャッシュには古いファイルが残っているため即時には反映されません。サービスワーカーは新旧バージョンの管理も行っており、通常は次回アクセス時に新バージョンを検知して自動更新します。これをユーザーに通知して「新しいバージョンがあります。リロードしますか？」といったUXを実装することも可能です。業務利用の場合、いつリロードされるかによって作業中データが消えるリスクもあるので、**PWA更新タイミングの設計**も考慮しましょう。

- **Capacitorの活用:**  Ionicアプリは必要に応じてCapacitorプラグインを使うことでデバイスのネイティブ機能を利用できます。イントラネットPWAの場合、モバイル端末での利用や将来的なハイブリッドアプリ展開もあり得ます。その際、**Capacitorプラグインをインフラ層に組み込んでおくと移行が容易**です。例えばカメラで撮影した写真をアップロードする機能が欲しい場合、CapacitorのCameraプラグインをInfra層に実装し（`PhotoService`などを作成）、Interaction層でそれを呼び出してからバックエンドAPIに送信する流れにします。同様に、ファイルシステムアクセスやバーコードスキャナ、地図表示（Google Maps JavaScript API＋Capacitor Geolocation等）の利用も考えられます。これらを直接ビューやコントローラ層に書くのではなく、**Infra層に隠蔽**することでテストしやすくなり、プラグイン差し替え時も影響を局所化できます。
    
    また、Capacitorには**Push通知**や**ローカル通知**の機能もあり、バックエンドと連携してリアルタイムなお知らせをユーザーに届けることも可能です。これらはモバイルアプリとしてデプロイする際に威力を発揮しますが、PWAとしてもChromeのプッシュ通知（Service Worker経由）で同様のことができます。業務アプリでは、重要なイベント（例：承認依頼など）を通知で知らせるニーズもあるため、必要ならバックエンドのSpring側でWebPush (RFC8030)に対応し、フロントのService Workerで受信・表示する仕組みも検討してください。
    
**学習リソース**：各ステップで参考になる資料として、SpringおよびReact/Ionicのドキュメントや実装例を挙げておきます。Springについては公式リファレンスや入門書のほか、以下のような日本語記事が役立ちます。

- Spring MVC/3層アーキテクチャ解説記事 ([Spring MVC についてまとめてみるよ！！！ #spring - Qiita](https://qiita.com/PonPon3/items/76318ab3524c43630761#:~:text=MVC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AFweb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%82%8B%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%88%9D%E3%82%81%E3%81%A6reils%E3%81%A7%E3%83%9D%E3%83%BC%E3%83%88%E3%83%95%E3%82%A9%E3%83%AA%E3%82%AA%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86%E3%81%A8%E3%81%97%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%83%95%E3%81%AF%E5%88%9D%E3%82%81%E3%81%A6%E7%9F%A5%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%E3%81%9F%E3%81%A0%E3%80%81SpringM%20VC%E3%81%AF%E5%8E%B3%E5%AF%86%E3%81%AB%E3%81%AF%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%83%95%E3%82%82%E5%8D%81%E5%88%86%E3%81%AB%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%8C%E3%80%81%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%82%92%E4%B8%80%E6%97%A6%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%20%E3%83%BC%E3%81%A8%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%20%E3%82%89%E3%81%97%E3%81%84%E3%80%82%20%E4%B8%80%E6%96%B9%E3%80%81SpringMVC%E3%81%AE%E7%89%B9%E5%BE%B4%E3%81%AF%E4%BB%A5%E4%B8%8B%E3%81%AE%E9%80%9A%E3%82%8A%E3%81%A7%E3%81%99%E3%80%82)) ([主要なSpringアノテーションの役割と使い方 | 株式会社一創](https://www.issoh.co.jp/tech/details/2639/#:~:text=%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%81%A7%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E5%88%86%E9%9B%A2%E3%81%97%E3%80%81%E5%86%8D%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%AA%E6%96%B9%E6%B3%95%E3%81%A7%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82%20%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E4%BF%9D%E5%AE%88%E6%80%A7%E3%81%A8%E3%83%86%E3%82%B9%E3%83%88%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E5%90%91%E4%B8%8A%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%82%92%E8%A8%AD%E8%A8%88%E3%81%97%E3%81%BE%E3%81%99%EF%BC%9A))（MVCの役割やサービス層の重要性を解説）
- レイヤードアーキテクチャ概論 ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%83%89%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%81%A8%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E3%81%AE%E5%B1%A4%E3%81%AB%E5%88%86%E5%89%B2%E3%81%97%E3%80%81%E5%90%84%E5%B1%A4%E3%81%8C%E7%89%B9%E5%AE%9A%E3%81%AE%E5%BD%B9%E5%89%B2%E3%82%92%E6%8C%81%E3%81%A4%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%99%E3%80%82)) ([ソリューションアーキテクチャーデザイン連載(10/13)：レイヤードアーキテクチャーとは何ですか? - クリエーションライン株式会社](https://www.creationline.com/tech-blog/microservices/solution-architecture-design/60259#:~:text=,%E6%9F%94%E8%BB%9F%E6%80%A7))（分割方法とメリットデメリット）
- クリーンアーキテクチャ現場適用に関する議論 ([クリーンアーキテクチャの功罪](https://zenn.dev/adwd/articles/5d4a89262f4fc5#:~:text=%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A8%E3%81%84%E3%81%86%E3%81%A8%E8%A8%AD%E8%A8%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E9%8A%80%E3%81%AE%E5%BC%BE%E4%B8%B8%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E6%89%B1%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E8%A8%98%E4%BA%8B%E3%82%92%E3%82%88%E3%81%8F%E8%A6%8B%E3%81%BE%E3%81%99%E3%80%82%E3%81%97%E3%81%8B%E3%81%97%E8%87%AA%E5%88%86%E3%81%AE%E7%B5%8C%E9%A8%93%E3%81%A0%E3%81%A8%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%20%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A7%E6%9B%B8%E3%81%8B%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%AB%E3%82%82%E3%81%8B%E3%81%8B%E3%82%8F%E3%82%89%E3%81%9A%E9%96%8B%E7%99%BA%E5%8A%B9%E7%8E%87%E3%81%8C%E8%90%BD%E3%81%A1%E3%81%A6%E3%81%84%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E4%BA%8B%E3%81%8C%E5%A4%9A%E3%81%8F%E3%80%81%E3%81%84%E3%81%A4%E3%81%A7%E3%82%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%91%E3%81%B0%E3%81%84%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E3%82%82%E3%81%AE%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))（クリーンアーキテクチャの功罪について開発者の視点）
- フロントエンドアーキテクチャ事例（React + TypeScriptでの層分割） ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=%E4%BB%A5%E4%B8%8B%E3%81%AE5%E3%81%A4%E3%81%AE%E5%B1%A4%E3%81%AB%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%82%92%E5%88%86%E5%89%B2%20Controller%E5%B1%A4%20Interaction%E5%B1%A4%20Model%E5%B1%A4%20View%E5%B1%A4,Infra%E5%B1%A4)) ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%A8Controller%E5%B1%A4%E3%81%AE%E8%AA%BF%E6%95%B4%E3%82%92%E8%A1%8C%E3%81%86%E5%B1%A4%E3%80%82%E7%94%BB%E9%9D%A2%E3%81%A7%E5%AE%9F%E7%8F%BE%E3%81%97%E3%81%9F%E3%81%84%E8%A6%81%E6%B1%82%E3%82%92%E8%A8%98%E8%BC%89%E3%81%99%E3%82%8B%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E6%A9%9F%E8%83%BD%E5%8D%98%E4%BD%8D%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%B5%81%E3%82%8C%E3%81%AF%E4%BB%A5%E4%B8%8B%E3%81%AE%E9%80%9A%E3%82%8A%E3%81%A8%E3%81%AA%E3%82%8B%20%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E5%A0%B4%E5%90%88%20%E3%83%BB%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%A8%E3%81%AE%E9%80%9A%E4%BF%A1%20%E3%83%BB,Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E7%94%9F%E6%88%90%20%E3%83%BB%E8%BF%94%E5%8D%B4%E3%81%95%E3%82%8C%E3%81%9F%E9%80%9A%E4%BF%A1%E7%B5%90%E6%9E%9C%E3%82%92Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E8%A8%AD%E5%AE%9A%20%E3%83%BBController%E5%B1%A4%E3%81%B8%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E5%8D%B4))（5層モデルの具体例）
- React×JWT認証の実装解説 ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=JWT%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E4%BB%96%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AB%E9%A0%BC%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E8%AA%8D%E8%A8%BC%E3%82%92%E8%A1%8C%E3%81%86%E4%B8%8A%E3%81%A7%E3%80%81%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E5%81%B4%E3%81%AFaccess_token%E3%82%92%E9%80%81%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%BE%E3%81%9F%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E7%84%A1%E5%8A%B9%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81r%20efresh_token%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%80%81%E6%96%B0%E3%81%9F%E3%81%AB%E6%9C%89%E5%8A%B9%E3%81%AAaccess_token%E3%82%92%E5%8F%96%E5%BE%97%E3%81%97%E7%9B%B4%E3%81%99%E3%81%93%E3%81%A8%E3%82%82%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82)) ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=export%20const%20authAxios%20%3D%20axios.create%28,%7D%2C%20withCredentials%3A%20true%2C))（axiosインターセプターやトークン管理方法）
- Ionic公式ドキュメント（PWAオフライン対応やサービスワーカー） ([Progressive Web Applications: PWAとは - Ionic Documentation](https://ionicframework.com/docs/ja/core-concepts/what-are-progressive-web-apps#:~:text=))

などがあります。特にフロントエンドの設計については最近の知見が英語情報に多いため、高品質な英語リソースも活用してください（例: *Atomic Design*や*React Clean Architecture*に関する記事、*TanStack Query*や*Redux Toolkit*の公式ドキュメントなど）。業務開発では、これらアーキテクチャを学んだ上でも現場の状況に適した取捨選択が求められます。本計画で段階的に習得しつつ、実プロジェクトに合わせて柔軟に適用してください。 ([Spring MVC についてまとめてみるよ！！！ #spring - Qiita](https://qiita.com/PonPon3/items/76318ab3524c43630761#:~:text=MVC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AFweb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%82%8B%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%88%9D%E3%82%81%E3%81%A6reils%E3%81%A7%E3%83%9D%E3%83%BC%E3%83%88%E3%83%95%E3%82%A9%E3%83%AA%E3%82%AA%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86%E3%81%A8%E3%81%97%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%83%95%E3%81%AF%E5%88%9D%E3%82%81%E3%81%A6%E7%9F%A5%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%E3%81%9F%E3%81%A0%E3%80%81SpringM%20VC%E3%81%AF%E5%8E%B3%E5%AF%86%E3%81%AB%E3%81%AF%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A7%E3%80%81%E5%83%95%E3%82%82%E5%8D%81%E5%88%86%E3%81%AB%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%8C%E3%80%81%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%82%92%E4%B8%80%E6%97%A6%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%20%E3%83%BC%E3%81%A8%E3%81%A8%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%20%E3%82%89%E3%81%97%E3%81%84%E3%80%82)) ([Spring MVCとは？Bootとの違いや特徴、必要なスキルも紹介 | エンジニアスタイル](https://engineer-style.jp/articles/9746#:~:text=MVC%E3%81%A8%E3%81%AF%E3%80%81Model)) ([主要なSpringアノテーションの役割と使い方 | 株式会社一創](https://www.issoh.co.jp/tech/details/2639/#:~:text=%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%81%A7%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E5%88%86%E9%9B%A2%E3%81%97%E3%80%81%E5%86%8D%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%AA%E6%96%B9%E6%B3%95%E3%81%A7%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82%20%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E4%BF%9D%E5%AE%88%E6%80%A7%E3%81%A8%E3%83%86%E3%82%B9%E3%83%88%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E5%90%91%E4%B8%8A%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%B1%A4%E3%82%92%E8%A8%AD%E8%A8%88%E3%81%97%E3%81%BE%E3%81%99%EF%BC%9A)) ([クリーンアーキテクチャの功罪](https://zenn.dev/adwd/articles/5d4a89262f4fc5#:~:text=%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A8%E3%81%84%E3%81%86%E3%81%A8%E8%A8%AD%E8%A8%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E9%8A%80%E3%81%AE%E5%BC%BE%E4%B8%B8%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E6%89%B1%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E8%A8%98%E4%BA%8B%E3%82%92%E3%82%88%E3%81%8F%E8%A6%8B%E3%81%BE%E3%81%99%E3%80%82%E3%81%97%E3%81%8B%E3%81%97%E8%87%AA%E5%88%86%E3%81%AE%E7%B5%8C%E9%A8%93%E3%81%A0%E3%81%A8%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%20%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A7%E6%9B%B8%E3%81%8B%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%AB%E3%82%82%E3%81%8B%E3%81%8B%E3%82%8F%E3%82%89%E3%81%9A%E9%96%8B%E7%99%BA%E5%8A%B9%E7%8E%87%E3%81%8C%E8%90%BD%E3%81%A1%E3%81%A6%E3%81%84%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E4%BA%8B%E3%81%8C%E5%A4%9A%E3%81%8F%E3%80%81%E3%81%84%E3%81%A4%E3%81%A7%E3%82%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%91%E3%81%B0%E3%81%84%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E3%82%82%E3%81%AE%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82)) ([フロントエンドに共通した設計パターンを確立する](https://zenn.dev/umeko5263/articles/14965e4deeeae7#:~:text=Model%E5%B1%A4%E3%81%A8Controller%E5%B1%A4%E3%81%AE%E8%AA%BF%E6%95%B4%E3%82%92%E8%A1%8C%E3%81%86%E5%B1%A4%E3%80%82%E7%94%BB%E9%9D%A2%E3%81%A7%E5%AE%9F%E7%8F%BE%E3%81%97%E3%81%9F%E3%81%84%E8%A6%81%E6%B1%82%E3%82%92%E8%A8%98%E8%BC%89%E3%81%99%E3%82%8B%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E6%A9%9F%E8%83%BD%E5%8D%98%E4%BD%8D%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%B5%81%E3%82%8C%E3%81%AF%E4%BB%A5%E4%B8%8B%E3%81%AE%E9%80%9A%E3%82%8A%E3%81%A8%E3%81%AA%E3%82%8B%20%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E5%A0%B4%E5%90%88%20%E3%83%BB%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89API%E3%81%A8%E3%81%AE%E9%80%9A%E4%BF%A1%20%E3%83%BB,Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E7%94%9F%E6%88%90%20%E3%83%BB%E8%BF%94%E5%8D%B4%E3%81%95%E3%82%8C%E3%81%9F%E9%80%9A%E4%BF%A1%E7%B5%90%E6%9E%9C%E3%82%92Model%E5%B1%A4%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E8%A8%AD%E5%AE%9A%20%E3%83%BBController%E5%B1%A4%E3%81%B8%E7%B5%90%E6%9E%9C%E3%82%92%E8%BF%94%E5%8D%B4)) ([React × JWT認証にはaxiosのInterceptors – miracleave Tech Blog](https://www.miracleave.co.jp/contents/1654/react-jwt-axios-interceptors/#:~:text=export%20const%20authAxios%20%3D%20axios.create%28,%7D%2C%20withCredentials%3A%20true%2C)) ([Progressive Web Applications: PWAとは - Ionic Documentation](https://ionicframework.com/docs/ja/core-concepts/what-are-progressive-web-apps#:~:text=))

